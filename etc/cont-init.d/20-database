#! /usr/bin/with-contenv bash
# shellcheck shell=bash

print_msg () { printf '[%s] %s' "${0##*/}" "${@}"; }
echo_msg () { print_msg "${*}"; echo; }

DSN="${USQL_SCHEME}://${OXPKI_DB_USER}:${OXPKI_DB_PASS}@${OXPKI_DB_HOST}:${OXPKI_DB_PORT}/${OXPKI_DB_NAME}"
DSN_ROOT="${USQL_SCHEME}://${OXPKI_DB_ROOT_USER}:${OXPKI_DB_ROOT_PASS}@${OXPKI_DB_HOST}:${OXPKI_DB_PORT}"

db_cmd () {	set -x; usql "${DSN}${usql_cmd_append}" "${@}" 2>&1;	}
db_root_cmd () { set -x; usql "${DSN_ROOT}${usql_cmd_append}" "${@}" 2>&1; }

usql_cmd_append=''

case "${USQL_SCHEME}" in
	postgres)
		db_create_db_cmd="CREATE DATABASE ${OXPKI_DB_NAME} ENCODING utf8;"
		db_create_user_cmd="CREATE USER ${OXPKI_DB_USER} WITH PASSWORD '${OXPKI_DB_PASS}';"
		db_grant_user_cmd="GRANT ALL ON DATABASE ${OXPKI_DB_NAME} TO ${OXPKI_DB_USER};"
		db_count_tables_cmd="SELECT COUNT (*) FROM information_schema.tables WHERE table_schema = 'public';"
		# sslmode: "require" (default), "verify-full", "verify-ca", or "disable"
		usql_cmd_append="?sslmode=${OXPKI_DB_SSLMODE:-disable}"
		;;
	mysql)
		db_create_db_cmd="CREATE DATABASE ${OXPKI_DB_NAME} CHARSET utf8;"
		db_create_user_cmd="CREATE USER '${OXPKI_DB_USER}'@'%' IDENTIFIED BY '${OXPKI_DB_PASS}';"
		db_grant_user_cmd="GRANT ALL ON ${OXPKI_DB_NAME}.* TO '${OXPKI_DB_USER}'@'%';"
		db_count_tables_cmd="SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'openxpki';"
		;;
	sqlite3)
		db_count_tables_cmd="SELECT count(*) FROM sqlite_master WHERE type = 'table';"
		DSN="${USQL_SCHEME}://${OXPKI_DB_NAME}" "${@}"
		[ -d "${OXPKI_DB_NAME%/*}" ] || mkdir -p "${OXPKI_DB_NAME%/*}"
		[ -f "${OXPKI_DB_NAME}" ] || db_cmd -qc '\Z'
		chown -R openxpki:openxpki "${OXPKI_DB_NAME%/*}"
		;;
	db2)
		db_create_db_cmd=""
		db_create_user_cmd=""
		db_grant_user_cmd=""
		db_count_tables_cmd=""
		;;
	oracle)
		# this mostly works against Oracle 18c Express Edition but the PDB won't open
		[ -n "${OXPKI_DB_ORACLE_FILE_DEST}" ] \
			&& db_create_db_cmd="CREATE PLUGGABLE DATABASE ${OXPKI_DB_NAME} ADMIN USER ${OXPKI_DB_USER} IDENTIFIED BY ${OXPKI_DB_PASS} ROLES=(DBA, PDB_DBA) CREATE_FILE_DEST='${OXPKI_DB_ORACLE_FILE_DEST}';" \
			|| db_create_db_cmd=""
		db_create_user_cmd="CREATE USER ${OXPKI_DB_USER} IDENTIFIED BY ${OXPKI_DB_PASS}; GRANT sysdba to ${OXPKI_DB_USER};"
		db_grant_user_cmd="GRANT CREATE TABLE, CREATE SEQUENCE TO ${OXPKI_DB_NAME};"
		db_count_tables_cmd="SELECT count(*) FROM all_tables where owner='$(echo "${OXPKI_DB_USER}" | tr '[:lower:]' '[:upper:]')';"
		DSN_ROOT="${USQL_SCHEME}://${OXPKI_DB_ROOT_USER}:${OXPKI_DB_ROOT_PASS}@${OXPKI_DB_HOST}:${OXPKI_DB_PORT}/${OXPKI_DB_ORACLE_SID}"
		waitfor_db_override=('set' '-x;' 'usql' "${USQL_SCHEME}://${OXPKI_DB_USER}:${OXPKI_DB_PASS}@${OXPKI_DB_HOST}:${OXPKI_DB_PORT}/${OXPKI_DB_ORACLE_SID}" '-c' '\Z' '2>&1')
		create_user_override=('set' '-x;' 'usql' "${USQL_SCHEME}://${OXPKI_DB_USER}:${OXPKI_DB_PASS}@${OXPKI_DB_HOST}:${OXPKI_DB_PORT}/${OXPKI_DB_NAME}" '-qc' "${db_create_user_cmd} ALTER PLUGGABLE DATABASE ${OXPKI_DB_NAME} OPEN; \Z" '2>&1')
		grant_user_override=('set' '-x;' 'usql' "${USQL_SCHEME}://${OXPKI_DB_USER}:${OXPKI_DB_PASS}@${OXPKI_DB_HOST}:${OXPKI_DB_PORT}/${OXPKI_DB_NAME}" '-qc' "${db_grant_user_cmd} \Z" '2>&1')
		;;
	*) echo_msg "ERROR: invalid USQL_SCHEME (${USQL_SCHEME}) or OXPKI_DB_TYPE (${OXPKI_DB_TYPE})"; exit 1 ;;
esac


# this method checks for an open port on the database host without needing to use
# the database client, but it generates error logs on the server tagged with this
# container's IP which doesn't make their origin immediately obvious
waitfor_db_devtcp () {
	local count; count=0
	local max_count; max_count=${OXPKI_DB_MAX_RETRIES:-30}

	print_msg 'Checking database connection.. '
	while ! 2>/dev/null > "/dev/tcp/${OXPKI_DB_HOST}/${OXPKI_DB_PORT}"; do
		count=$((count + 1))
		if [ $count -ge 30 ]; then
			echo 'FAIL'		
			echo_msg "Could not connect to: ${DSN/${OXPKI_DB_USER}:${OXPKI_DB_PASS}@/}"
			echo_msg 'Too many retries.'
			return 1
		fi

		echo;	print_msg "Could not connect to ${OXPKI_DB_HOST}, will retry.. "
		sleep 5
	done && echo 'OK'
}

# this method talks to the server in a language it expects. although it still
# generates some logs they'll usually be clearer and should be tagged with
# 'openxpki', so at least they're not potentially alarming mystery logs
waitfor_db () {
	local count; count=0
	local max_count; max_count=${OXPKI_DB_MAX_RETRIES:-30}

	print_msg 'Checking database connection.. '
#	while ! result="$(db_cmd -qc '\Z')"; do
	while ! result="$(${waitfor_db_override:-db_cmd -qc '\Z'})"; do
		count=$((count + 1))
		if [ $count -ge "${max_count}" ]; then
			echo 'FAIL'
			echo_msg "Could not connect to: ${DSN/${OXPKI_DB_USER}:${OXPKI_DB_PASS}@/}"
			echo_msg "${result}"
			echo_msg 'Too many retries.'
			return 1
		fi

		# allowed errors:
		#
		# error: mysql: 1045: Access denied for user ''@'<XXXXX>' (using password: NO)
		# error: mysql: 1049: Unknown database '<XXXXX>'
		# error: oracle: ORA-01017: invalid username/password; logon denied
		# error: pq: 28P01: password authentication failed for user "<XXXXX>"
		case "${result}" in
			*'1045'*|*'1049'*|*'28P01'*|*'01017'*) break ;;
			*) echo;	print_msg "Could not connect, will retry (${count}).. "
				sleep 5
				;;
		esac
	done && echo 'OK'
}


# check the user login and the existance of the database in one go, any
# failure at all triggers individual testing for the various things we need
check_db () {
	print_msg 'Checking database access.. '
	result="$(db_cmd -qc '\Z')" || { echo 'no access!'; echo "${result}"; return 1; }
	echo 'OK'
}

create_db () {
	# skip creation for sqlite, any of the previous commands will have created it
	[ "${USQL_SCHEME}" = 'sqlite3' ] && return

	local failed; unset failed

	print_msg 'Checking root access.. '
	[ -z "${OXPKI_DB_ROOT_USER+set}" ] \
		&& { echo 'ERROR: No root user found in OXPKI_DB_ROOT_USER'; failed=1; }
  [ -z "${OXPKI_DB_ROOT_PASS+set}" ] \
		&& { echo 'ERROR: No root password found in OXPKI_DB_ROOT_PASS'; failed=1; }

	[ -n "${failed}" ] && exit 1

	result="$(db_root_cmd -qc '\Z')" || { echo "${result}"; exit 1; }
	echo 'OK'

	# allowed errors:
	#
	# error: mysql: 1007: Can't create database '<XXXXX>'; database exists
	# error: oracle: ORA-65012: Pluggable database OPENXPKI3 already exists.
	# error: pq: 42P04: database "<XXXXX>" already exists
	print_msg 'Creating database.. '
	if [ -z "${db_create_db_cmd}" ]; then
		echo 'skipped'
		echo_msg 'Cannot create database for this driver.'
	elif ! result="$(db_root_cmd -qc "${db_create_db_cmd} \Z")"; then
		case "${result}" in
			*'1007'*|*'42P04'*|*'65012'*) echo 'exists' ;;
			*) echo "${result}" && exit 1 ;;
		esac
	else echo 'OK'
	fi

	# allowed errors:
	#
	# error: mysql: 1396: Operation CREATE USER failed for '<XXXXX>'@'%'
	# error: pq: 42710: role "<XXXXX>" already exists
	print_msg 'Creating user.. '
#	if [ -z "${db_create_user_cmd}" ]; then
	if [ -z "${create_user_override:-"${db_create_user_cmd}"}" ]; then
		echo 'skipped'
		echo_msg 'Cannot create user for this driver.'
	elif ! result="$(${create_user_override:-db_root_cmd -qc "${db_create_user_cmd} \Z"})"; then
		case "${result}" in
			*'1396'*|*'42710'*) echo 'exists' ;;
			*) echo "${result}" && exit 1 ;;
		esac
	else echo 'OK'
	fi

	print_msg 'Granting permissions.. '
#	if [ -z "${db_grant_user_cmd}" ]; then
	if [ -z "${grant_user_override:-${db_grant_user_cmd}}" ]; then
		echo 'skipped'
		echo_msg 'Cannot grant permissions for this driver.'
	elif ! result="$(${grant_user_override:-db_root_cmd -qc "${db_grant_user_cmd} \Z"})"; then
		case "${result}" in
			*) echo "${result}" && exit 1 ;;
		esac
	else echo 'OK'
	fi

#	db_root_cmd -qc 'flush privileges; \Z' >/dev/null
}

check_db_tables () {
	# allowed errors:
	#
	# error: oracle: ORA-00942: table or view does not exist
	print_msg 'Checking tables exist.. '
	if ! table_count="$(db_cmd -qAtc "${db_count_tables_cmd} \Z")"; then
		case "${table_count}" in
			'0'|*'00942'*) echo 'missing' && return 1 ;;
			*) echo "${table_count}" && exit 1 ;;
		esac
	else echo "OK (${table_count})"
	fi
}

create_db_tables () {
	schema_file="/etc/openxpki/contrib/sql/schema-${OXPKI_SCHEMA_FILE}.sql"

	print_msg "Creating tables from ${schema_file}.. "
	[ ! -f "${schema_file}" ] && echo "ERROR: no schema at ${schema_file}" && return 1

	# append a usql close command to the schema file, otherwise we don't exit clean
	[ "$(tail -n1 "${schema_file}")" != '\Z' ] && printf '\n\Z\n' >> "${schema_file}"

	# allowed errors:
	#
	# error: pq: 42501: must be owner of extension plpgsql
	# error: pq: 42P07: relation <XXXXX> already exists
	# error: pq: 42P16: multiple primary keys for table <XXXXX> are not allowed
	# error: oracle: ORA-00942: table or view does not exist
	# error: oracle: ORA-02289: sequence does not exist
	if ! result="$(db_cmd -qf "${schema_file}")"; then
		local failed; failed=''
		while IFS= read -r line; do
			[ "${line/error/}" = "${line}" ] && continue
			case "${line}" in
				*'42501'*|*'42P07'*|*'42P16'*|*'00942'*|*'02289'*) true ;;
				*) echo "${line}" && failed='true' ;;
			esac
		done <<< "${result}"
		[ -n "${failed}" ] && exit 1
	fi

	echo 'OK'
}


# wait until we can connect to the database server or time out
waitfor_db || { echo '*** ERROR ***'; exit 1; }

# check we can access the database, otherwise create database and user
if ! check_db; then
	create_db;
	check_db || { echo '*** ERROR ***'; exit 1; }
fi

# check database tables exist, otherwise create them
if ! check_db_tables; then
	create_db_tables
	check_db_tables || { echo '*** ERROR ***'; exit 1; }
fi
