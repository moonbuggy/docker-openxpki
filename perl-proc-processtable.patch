diff --git a/Makefile.PL b/Makefile.PL
index 805e448..371ea91 100644
--- a/Makefile.PL
+++ b/Makefile.PL
@@ -17,7 +17,7 @@ my %WriteMakefileArgs = (
     ABSTRACT_FROM    => 'lib/Proc/ProcessTable.pm',
     LICENSE          => 'artistic_2',
     'LDFROM'    => '$(O_FILES)',
-    'LIBS'     => [''],
+    'LIBS'     => ['-lobstack'],
     'OBJECT'    => 'ProcessTable.o OS.o',
     MIN_PERL_VERSION => '5.006',
     CONFIGURE_REQUIRES => {
diff --git a/os/Linux.c b/os/Linux.c
index 987bc62..023a884 100644
--- a/os/Linux.c
+++ b/os/Linux.c
@@ -328,7 +328,11 @@ static bool get_proc_stat(char *pid, char *format_str, struct procstat* prs,
     /* scan in pid, and the command, in linux the command is a max of 15 chars
      * plus a terminating NULL byte; prs->comm will be NULL terminated since
      * that area of memory is all zerored out when prs is allocated */
-    if (sscanf(stat_text, "%d (%15c", &prs->pid, prs->comm) != 2)
+    /* Apparently %15c means 'exactly 15' but a glibc bug allows matching
+     * regardles. musl won't match it.
+     * See: https://www.openwall.com/lists/musl/2013/11/15/5
+     * and: https://sourceware.org/bugzilla/show_bug.cgi?id=12701 */
+    if (sscanf(stat_text, "%d (%c", &prs->pid, prs->comm) != 2)
       /* we might get an empty command name, so check for it:
        * do the open and close parenteses lie next to each other?
        * proceed if yes, finish otherwise
@@ -393,7 +397,8 @@ static void eval_link(char *pid, char *link_rel, enum field field, char **ptr,
      * for the cwd symlink, since on linux the links we care about will never
      * be relative links (cwd, exec)
      * Doing this because readlink works on static buffers */
-    link = canonicalize_file_name(link_file);
+    /* canonicalize_file_name is no good for musl, use realpath instead */
+    link = realpath(link_file, NULL);

     /* we no longer need need the path to the link file */
     obstack_free(mem_pool, link_file);
diff --git a/t/process.t b/t/process.t
index 3bd6853..16a8c07 100644
--- a/t/process.t
+++ b/t/process.t
@@ -84,5 +84,6 @@ else
 {
   # child, fork returned 0
   # child process will be killed soon
-  sleep 10000;
+  # 10,000 seconds is a long time to wait
+  sleep 10;
 }
